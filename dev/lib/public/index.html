<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · HypothesisTestsExtra.jl</title><meta name="title" content="API Reference · HypothesisTestsExtra.jl"/><meta property="og:title" content="API Reference · HypothesisTestsExtra.jl"/><meta property="twitter:title" content="API Reference · HypothesisTestsExtra.jl"/><meta name="description" content="Documentation for HypothesisTestsExtra.jl."/><meta property="og:description" content="Documentation for HypothesisTestsExtra.jl."/><meta property="twitter:description" content="Documentation for HypothesisTestsExtra.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/welch_fisher/">Welch ANOVA &amp; Fisher RxC</a></li><li><a class="tocitem" href="../../man/posthoc_theory/">Post-Hoc Analysis Guide</a></li><li><a class="tocitem" href="../../man/dataframes/">DataFrame Integration</a></li></ul></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#New-Hypothesis-Tests"><span>New Hypothesis Tests</span></a></li><li><a class="tocitem" href="#Post-Hoc-Analysis"><span>Post-Hoc Analysis</span></a></li><li><a class="tocitem" href="#DataFrame-Extensions"><span>DataFrame Extensions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/songtaogui/HypothesisTestsExtra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/master/docs/src/lib/public.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="New-Hypothesis-Tests"><a class="docs-heading-anchor" href="#New-Hypothesis-Tests">New Hypothesis Tests</a><a id="New-Hypothesis-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#New-Hypothesis-Tests" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="HypothesisTestsExtra.WelchANOVATest"><a class="docstring-binding" href="#HypothesisTestsExtra.WelchANOVATest"><code>HypothesisTestsExtra.WelchANOVATest</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WelchANOVATest(groups)
WelchANOVATest(groups::AbstractVector{&lt;:Real}...)
WelchANOVATest(df::DataFrame, group_col::Symbol, data_col::Symbol)</code></pre><p>Perform Welch&#39;s ANOVA test of the hypothesis that the <code>groups</code> means are equal. This test is an alternative to the standard One-Way ANOVA when the assumption of  equal variances (homoscedasticity) is violated.</p><p>The test statistic is approximately F-distributed.</p><p>Implements: <a href="@ref"><code>pvalue</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># input arrays
WelchANOVATest(randn(10), randn(15).+1, randn(12).+2)

# input DataFrame
using StatsBase, DataFrames
cdf = DataFrame(A = sample([&quot;G1&quot;,&quot;G2&quot;], 100), B = sample(randn(10), 100))
WelchANOVATest(cdf, :A, :B)</code></pre><p><strong>External links</strong></p><ul><li><a href="https://en.wikipedia.org/wiki/Welch%27s_t-test">Welch&#39;s t-test and ANOVA on Wikipedia</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/welch.jl#L7-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTestsExtra.FisherExactTestRxC"><a class="docstring-binding" href="#HypothesisTestsExtra.FisherExactTestRxC"><code>HypothesisTestsExtra.FisherExactTestRxC</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">FisherExactTestRxC(tbl::AbstractMatrix{&lt;:Integer})</code></pre><p>A smart constructor that acts as a drop-in replacement for Fisher&#39;s Exact Test.</p><ul><li>If <code>tbl</code> is <strong>2x2</strong>, it returns a standard <code>HypothesisTests.FisherExactTest</code> object  (calculating the exact p-value deterministically and supporting Odds Ratio CI).</li><li>If <code>tbl</code> is <strong>RxC</strong> (where R&gt;2 or C&gt;2), it returns a <code>FisherExactTestMC</code> object  (estimating the p-value via Monte Carlo simulation).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/fisherrxc.jl#L24-L33">source</a></section><section><div><pre><code class="language-julia hljs">FisherExactTestRxC(df::DataFrame, row_col::Symbol, col_col::Symbol)</code></pre><p>Compute Fisher&#39;s Exact Test for general RxC tables from a raw DataFrame.</p><p>This function aggregates the DataFrame columns into a contingency table and then applies <code>FisherExactTestRxC</code>.</p><ul><li>If the resulting table is 2x2, it calculates the exact p-value.</li><li>If the resulting table is RxC (larger than 2x2), it estimates the p-value via Monte Carlo simulation.</li></ul><p><strong>Arguments</strong></p><ul><li><code>df</code>: DataFrame containing raw observations.</li><li><code>row_col</code>: Column determining the table rows.</li><li><code>col_col</code>: Column determining the table columns.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L268-L283">source</a></section><section><div><pre><code class="language-julia hljs">FisherExactTestRxC(df::DataFrame, row_col::Symbol, col_col::Symbol, freq_col::Symbol)</code></pre><p>Compute Fisher&#39;s Exact Test (RxC or 2x2) from aggregated frequency data (Long format).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L305-L309">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTestsExtra.FisherExactTestMC"><a class="docstring-binding" href="#HypothesisTestsExtra.FisherExactTestMC"><code>HypothesisTestsExtra.FisherExactTestMC</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FisherExactTestMC(tbl::AbstractMatrix{&lt;:Integer})</code></pre><p>Internal struct for performing Monte Carlo Fisher&#39;s exact test on R x C tables. Users should generally use <code>FisherExactTestRxC</code> which automatically selects between this and the exact 2x2 test.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/fisherrxc.jl#L5-L11">source</a></section></details></article><h2 id="Post-Hoc-Analysis"><a class="docs-heading-anchor" href="#Post-Hoc-Analysis">Post-Hoc Analysis</a><a id="Post-Hoc-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Post-Hoc-Analysis" title="Permalink"></a></h2><h3 id="Parametric-and-Non-Parametric"><a class="docs-heading-anchor" href="#Parametric-and-Non-Parametric">Parametric &amp; Non-Parametric</a><a id="Parametric-and-Non-Parametric-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-and-Non-Parametric" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="HypothesisTestsExtra.PostHocTest"><a class="docstring-binding" href="#HypothesisTestsExtra.PostHocTest"><code>HypothesisTestsExtra.PostHocTest</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">PostHocTest(groups; method=:tukey, alpha=0.05, alpha_levene=0.05, cld=false, pairs=nothing, row_labels=[])</code></pre><p>Perform parametric post-hoc pairwise comparisons (Multiple Comparison Procedures) on a set of data groups.</p><p><strong>Arguments</strong></p><ul><li><code>groups::AbstractVector{&lt;:AbstractVector{&lt;:Real}}</code>: A vector of vectors, where each inner vector contains the numerical observations for a specific group.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>method::Symbol</code>: The post-hoc algorithm to use. Defaults to <code>:tukey</code>. See the <strong>Supported Methods</strong> section below for details on each option.</li><li><code>alpha::Float64</code>: The significance level (Type I error rate) for the hypothesis tests and confidence intervals. Defaults to <code>0.05</code>.</li><li><code>alpha_levene::Float64</code>: The threshold used for the internal Levene&#39;s test. If the p-value of Levene&#39;s test is below this value, a warning is issued suggesting the data has unequal variances (heteroscedasticity) and recommending <code>:tamhane</code>. Defaults to <code>0.05</code>.</li><li><code>cld::Bool</code>: If <code>true</code>, generates Compact Letter Display (CLD) codes. Groups sharing the same letter are not significantly different. Defaults to <code>false</code>.</li><li><code>pairs</code>: An optional <code>Vector{Tuple{Int, Int}}</code> specifying a subset of group indices to compare (e.g., <code>[(1, 2), (1, 3)]</code>). If <code>nothing</code> (default), all possible pairwise combinations are tested.</li><li><code>row_labels</code>: Optional vector of strings to label the groups in the output. If empty, defaults to &quot;Group1&quot;, &quot;Group2&quot;, etc.</li></ul><p><strong>Supported Methods</strong></p><p>The <code>method</code> argument accepts the following symbols:</p><p><strong>1. Equal Variance Assumed (Homoscedasticity):</strong></p><ul><li><code>:tukey</code> (Default): <strong>Tukey&#39;s HSD (Honest Significant Difference)</strong>.   Based on the Studentized Range distribution. It controls the Family-Wise Error Rate (FWER) for all pairwise comparisons. It is the standard choice for balanced or slightly unbalanced designs.</li><li><code>:lsd</code>: <strong>Fisher&#39;s LSD (Least Significant Difference)</strong>.   Performs individual t-tests without FWER adjustment. It is the most powerful (least conservative) but carries a high risk of Type I errors (false positives) as the number of groups increases.</li><li><code>:bonferroni</code>: <strong>Bonferroni Correction</strong>.   Adjusts the significance level to <code>alpha / m</code> (where m is the number of tests). It is very conservative and strictly controls FWER, but often lacks power.</li><li><code>:sidak</code>: <strong>Sidak Correction</strong>.   Adjusts the significance level to <code>1 - (1 - alpha)^(1/m)</code>. It is slightly more powerful than Bonferroni while maintaining strict FWER control (assuming independence).</li><li><code>:scheffe</code>: <strong>Scheffe&#39;s Method</strong>.   Based on the F-distribution. It is designed to control FWER for <em>all possible</em> linear contrasts, not just pairwise comparisons. Consequently, it is extremely conservative for simple pairwise tests.</li><li><code>:snk</code>: <strong>Student-Newman-Keuls</strong>.   A stepwise multiple range procedure. It adjusts the critical value based on the number of steps between means. It is less conservative than Tukey but does not strictly control FWER in the strong sense.</li><li><code>:duncan</code>: <strong>Duncan&#39;s New Multiple Range Test</strong>.   Similar to SNK but uses a more liberal protection level. It has higher power but a higher rate of Type I errors compared to SNK or Tukey.</li></ul><p><strong>2. Unequal Variance Assumed (Heteroscedasticity):</strong></p><ul><li><code>:tamhane</code>: <strong>Tamhane&#39;s T2</strong>.   Uses Welch&#39;s t-test (which adjusts degrees of freedom for unequal variances) combined with a Sidak-like multiplicative correction for the p-value. This is the recommended method when Levene&#39;s test is significant.</li></ul><p><strong>Returns</strong></p><p>Returns a <code>PostHocTestResult</code> object containing detailed comparison statistics (diff, standard error, test statistic, critical value, p-value, confidence intervals) and CLD letters if requested.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">PostHocTest([randn(10), randn(10).+5, randn(10).+0.1]; cld = true, row_labels=[&quot;Control&quot;, &quot;TreatA&quot;, &quot;TreatB&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/PostHoc/posthoc_parametric.jl#L209-L255">source</a></section><section><div><pre><code class="language-julia hljs">PostHocTest(df::DataFrame, group_col::Symbol, data_col::Symbol; kwargs...)</code></pre><p>Perform parametric post-hoc pairwise comparisons (e.g., Tukey&#39;s HSD) directly on a DataFrame.</p><p><strong>Arguments</strong></p><ul><li><code>df</code>: The DataFrame containing the raw data.</li><li><code>group_col</code>: Symbol representing the column with group labels.</li><li><code>data_col</code>: Symbol representing the column with numerical observations.</li><li><code>kwargs</code>: Arguments passed to the core <code>PostHocTest</code> function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L111-L121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTestsExtra.PostHocNonPar"><a class="docstring-binding" href="#HypothesisTestsExtra.PostHocNonPar"><code>HypothesisTestsExtra.PostHocNonPar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">PostHocNonPar(groups; method=:dunn_bonferroni, alpha=0.05, cld=false, pairs=nothing, row_labels=[])</code></pre><p>Perform non-parametric post-hoc pairwise comparisons on a set of data groups.  This function is typically used after a significant Kruskal-Wallis test to determine which specific groups differ. It operates on the <strong>ranks</strong> of the data rather than the raw values.</p><p><strong>Arguments</strong></p><ul><li><code>groups::AbstractVector{&lt;:AbstractVector{&lt;:Real}}</code>: A vector of vectors, where each inner vector contains the numerical observations for a specific group.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>method::Symbol</code>: The post-hoc algorithm to use. Defaults to <code>:dunn_bonferroni</code>. See the <strong>Supported Methods</strong> section below for details.</li><li><code>alpha::Float64</code>: The significance level (Type I error rate). Defaults to <code>0.05</code>.</li><li><code>cld::Bool</code>: If <code>true</code>, generates Compact Letter Display (CLD) codes based on the rank comparisons. Groups sharing the same letter are not significantly different. Defaults to <code>false</code>.</li><li><code>pairs</code>: An optional <code>Vector{Tuple{Int, Int}}</code> specifying a subset of group indices to compare. If <code>nothing</code> (default), all possible pairwise combinations are tested.</li><li><code>row_labels</code>: Optional vector of strings to label the groups in the output. If empty, defaults to &quot;Group1&quot;, &quot;Group2&quot;, etc.</li></ul><p><strong>Supported Methods</strong></p><p>The <code>method</code> argument accepts the following symbols. All methods automatically apply a tie correction factor to the standard error if ties are present in the data.</p><p><strong>1. Dunn&#39;s Test (Z-test based):</strong> Dunn&#39;s test approximates the distribution of the difference in mean ranks using a normal distribution (Z-test). It allows for various p-value adjustment methods to control the Family-Wise Error Rate (FWER).</p><ul><li><code>:dunn</code>: <strong>Unadjusted Dunn&#39;s Test</strong>.   Performs raw comparisons without correcting for multiple testing. High power but high risk of Type I errors (false positives).</li><li><code>:dunn_bonferroni</code> (Default): <strong>Dunn&#39;s Test with Bonferroni Correction</strong>.   Adjusts p-values by multiplying by the number of tests. Strict FWER control, conservative.</li><li><code>:dunn_sidak</code>: <strong>Dunn&#39;s Test with Sidak Correction</strong>.   Adjusts p-values using <code>1 - (1 - p)^m</code>. Slightly more powerful than Bonferroni while maintaining FWER control.</li></ul><p><strong>2. Nemenyi Test (Studentized Range based):</strong></p><ul><li><code>:nemenyi</code>: <strong>Nemenyi Test</strong>.   This is the non-parametric equivalent of Tukey&#39;s HSD. It uses the Studentized Range distribution (approximated with infinite degrees of freedom) to determine critical values. It controls FWER for all pairwise comparisons and is generally more conservative than Dunn&#39;s test, especially for large numbers of groups.</li></ul><p><strong>Returns</strong></p><p>Returns a <code>PostHocTestResult</code> object containing detailed comparison statistics (diff in mean ranks, standard error, Z/Q statistic, critical value, p-value, confidence intervals) and CLD letters if requested.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># 3 groups with different distributions
g1 = rand(10)
g2 = rand(10) .+ 2
g3 = rand(10) .+ 0.5

# Perform Dunn&#39;s test with Bonferroni correction and generate CLD letters
result = PostHocNonPar([g1, g2, g3]; method=:dunn_bonferroni, cld=true, row_labels=[&quot;Ctrl&quot;, &quot;TrtA&quot;, &quot;TrtB&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/PostHoc/posthoc_nonparametric.jl#L7-L53">source</a></section><section><div><pre><code class="language-julia hljs">PostHocNonPar(df::DataFrame, group_col::Symbol, data_col::Symbol; kwargs...)</code></pre><p>Perform non-parametric post-hoc pairwise comparisons (e.g., Dunn&#39;s Test) directly on a DataFrame.</p><p><strong>Arguments</strong></p><ul><li><code>df</code>: The DataFrame containing the raw data.</li><li><code>group_col</code>: Symbol representing the column with group labels.</li><li><code>data_col</code>: Symbol representing the column with numerical observations.</li><li><code>kwargs</code>: Arguments passed to the core <code>PostHocNonPar</code> function (e.g., <code>method</code>, <code>alpha</code>, <code>p_adjust</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L95-L105">source</a></section></details></article><h3 id="Contingency-Tables"><a class="docs-heading-anchor" href="#Contingency-Tables">Contingency Tables</a><a id="Contingency-Tables-1"></a><a class="docs-heading-anchor-permalink" href="#Contingency-Tables" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="HypothesisTestsExtra.PostHocContingencyRow"><a class="docstring-binding" href="#HypothesisTestsExtra.PostHocContingencyRow"><code>HypothesisTestsExtra.PostHocContingencyRow</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">PostHocContingencyRow(table::AbstractMatrix{&lt;:Integer}; method=:chisq, adjustment=:bonferroni, cld=false, alpha=0.05, pairs=nothing, row_labels=[])</code></pre><p>Perform pairwise comparisons between rows of a contingency table to identify which groups differ significantly in their distribution across columns.</p><p><strong>Arguments</strong></p><ul><li><code>table::AbstractMatrix{&lt;:Integer}</code>: The RxC contingency table.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>method::Symbol</code>: The statistical test to use for pairwise comparisons.<ul><li><code>:chisq</code> (Default): Pearson&#39;s Chi-square test. Fast and standard for large samples.</li><li><code>:fisher</code>: Fisher&#39;s Exact Test. <ul><li>For <strong>2x2</strong> sub-tables, it computes the exact p-value.</li><li>For <strong>2xC</strong> sub-tables (where C &gt; 2), it estimates the p-value via Monte Carlo simulation (see <code>FisherExactTestRxC</code>).</li></ul></li></ul></li><li><code>adjustment::Symbol</code>: The method to adjust p-values for multiple comparisons.<ul><li><code>:bonferroni</code>: Strong control of FWER (p * m).</li><li><code>:bh</code> (or <code>:fdr</code>): Benjamini-Hochberg procedure for False Discovery Rate control.</li><li><code>:none</code>: No adjustment.</li></ul></li><li><code>alpha::Float64</code>: Significance level. Defaults to <code>0.05</code>.</li><li><code>cld::Bool</code>: If <code>true</code>, generates Compact Letter Display codes based on the proportion of the first column. Defaults to <code>false</code>.</li><li><code>pairs</code>: An optional <code>Vector{Tuple{Int, Int}}</code> specifying a subset of row indices to compare (e.g., <code>[(1, 2), (1, 3)]</code>). If <code>nothing</code> (default), all possible pairwise combinations are tested.</li><li><code>row_labels</code>: Optional vector of strings to label the rows in the output.</li></ul><p><strong>Returns</strong></p><p>Returns a <code>PostHocTestResult</code> object containing comparison statistics and adjusted p-values.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using HypothesisTests

# Data: 4 Groups (Rows) vs 3 Outcomes (Cols: Success, Neutral, Fail)
# Group 1 and 2 are similar, Group 3 is different, Group 4 is very different
table = [
    50 30 20; # Group 1
    48 32 20; # Group 2 (Similar to 1)
    20 40 40; # Group 3 (Different)
    10 10 80  # Group 4 (Very different)
]
row_labs = [&quot;Grp1&quot;, &quot;Grp2&quot;, &quot;Grp3&quot;, &quot;Grp4&quot;]

# 1. Standard Pairwise Chi-Square with Bonferroni adjustment
# Also requesting Compact Letter Display (cld=true)
res_chisq = PostHocContingencyRow(table, method=:chisq, adjustment=:bonferroni, 
                                  cld=true, row_labels=row_labs)

# Inspect the Compact Letter Display (if generated)
# println(res_chisq.letters) 
# Expected: Grp1 and Grp2 might share a letter (e.g., &quot;a&quot;), Grp3 &quot;b&quot;, Grp4 &quot;c&quot;

# 2. Pairwise Fisher&#39;s Exact Test (Robust for small counts and supports RxC)
# Only comparing Group 1 vs Group 4 and Group 1 vs Group 3
specific_pairs = [(1, 4), (1, 3)]
res_fisher = PostHocContingencyRow(table, method=:fisher, adjustment=:none,
                                   pairs=specific_pairs, row_labels=row_labs)

# Print p-values for the specific pairs
for cmp in res_fisher.comparisons
    println(&quot;Comparing $(row_labs[cmp.idx_a]) vs $(row_labs[cmp.idx_b]): p = $(cmp.p_val)&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/PostHoc/posthoc_contingency.jl#L333-L394">source</a></section><section><div><pre><code class="language-julia hljs">PostHocContingencyRow(df::DataFrame, row_col::Symbol, col_col::Symbol; kwargs...)</code></pre><p>Perform row-wise post-hoc comparisons (e.g., Chi-Sq or Fisher) on raw categorical data. The function automatically aggregates the data into a contingency table (counts) before analysis.</p><p><strong>Arguments</strong></p><ul><li><code>df</code>: DataFrame containing raw observations (one row per subject).</li><li><code>row_col</code>: Column determining the table rows (groups to compare).</li><li><code>col_col</code>: Column determining the table columns (outcomes).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L129-L139">source</a></section><section><div><pre><code class="language-julia hljs">PostHocContingencyRow(df::DataFrame, row_col::Symbol, col_col::Symbol, freq_col::Symbol; kwargs...)</code></pre><p>Perform row-wise post-hoc comparisons on aggregated frequency data (Long format).</p><p><strong>Arguments</strong></p><ul><li><code>df</code>: DataFrame containing aggregated counts.</li><li><code>row_col</code>: Column determining the table rows.</li><li><code>col_col</code>: Column determining the table columns.</li><li><code>freq_col</code>: Column containing the integer counts/frequencies.</li></ul><p><strong>Process</strong></p><p>Pivots the DataFrame into a matrix (using <code>unstack</code>), filling missing combinations with 0, then calls the core logic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L148-L161">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTestsExtra.PostHocContingencyCell"><a class="docstring-binding" href="#HypothesisTestsExtra.PostHocContingencyCell"><code>HypothesisTestsExtra.PostHocContingencyCell</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">PostHocContingencyCell(table::AbstractMatrix{&lt;:Integer}; method=:asr, adjustment=:bonferroni, alpha=0.05, row_labels=[], col_labels=[])</code></pre><p>Perform cell-level post-hoc analysis on a contingency table to identify specific cells that contribute significantly to the overall association.</p><p><strong>Arguments</strong></p><ul><li><code>table</code>: RxC contingency table (Matrix of Integers).</li><li><code>method</code>: <ul><li><code>:asr</code>: Adjusted Standardized Residuals. Tests if a cell deviates from independence.</li><li><code>:fisher_1vsall</code>: Fisher&#39;s Exact Test for each cell (One vs Rest).</li></ul></li><li><code>adjustment::Symbol</code>: The method to adjust p-values for multiple comparisons.<ul><li><code>:bonferroni</code>: Strong control of FWER (p * m).</li><li><code>:bh</code> (or <code>:fdr</code>): Benjamini-Hochberg procedure for False Discovery Rate control.</li><li><code>:none</code>: No adjustment.</li></ul></li><li><code>row_labels</code>: Optional vector of strings for row names.</li><li><code>col_labels</code>: Optional vector of strings for column names.</li></ul><p><strong>Returns</strong></p><p>A <code>ContingencyCellTestResult</code> object containing matrices for statistics, raw p-values, adjusted p-values, and significance flags.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using HypothesisTests, Distributions

# Create a 3x3 contingency table (e.g., 3 Age Groups vs 3 Preferences)
# Rows: Young, Middle, Old
# Cols: Option A, Option B, Option C
table = [
    30 10 10;  # Young mostly prefer A
    10 30 10;  # Middle mostly prefer B
    10 10 30   # Old mostly prefer C
]
r_labs = [&quot;Young&quot;, &quot;Middle&quot;, &quot;Old&quot;]
c_labs = [&quot;Opt_A&quot;, &quot;Opt_B&quot;, &quot;Opt_C&quot;]

# 1. Use Adjusted Standardized Residuals (ASR) with Bonferroni correction
res_asr = PostHocContingencyCell(table, method=:asr, adjustment=:bonferroni,
                                 row_labels=r_labs, col_labels=c_labs)

# Check the matrix of adjusted residuals (Z-scores)
# println(res_asr.stats_mat)

# Check which cells are significant (True/False matrix)
# println(res_asr.sig_mat)

# 2. Use One-vs-Rest Fisher&#39;s Exact Test with FDR (Benjamini-Hochberg) adjustment
res_fisher = PostHocContingencyCell(table, method=:fisher_1vsall, adjustment=:bh,
                                    row_labels=r_labs, col_labels=c_labs)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/PostHoc/posthoc_contingency.jl#L98-L148">source</a></section><section><div><pre><code class="language-julia hljs">PostHocContingencyCell(df::DataFrame, row_col::Symbol, col_col::Symbol; kwargs...)</code></pre><p>Perform cell-level post-hoc analysis (e.g., ASR) on raw categorical data.</p><p>The function automatically aggregates the data into a contingency table (counts) before analysis.</p><p><strong>Arguments</strong></p><ul><li><code>df</code>: DataFrame containing raw observations (one row per subject).</li><li><code>row_col</code>: Column determining the table rows (groups to compare).</li><li><code>col_col</code>: Column determining the table columns (outcomes).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L169-L180">source</a></section><section><div><pre><code class="language-julia hljs">PostHocContingencyCell(df::DataFrame, row_col::Symbol, col_col::Symbol, freq_col::Symbol; kwargs...)</code></pre><p>Perform cell-level post-hoc analysis on aggregated frequency data (Long format).</p><p><strong>Arguments</strong></p><ul><li><code>df</code>: DataFrame containing aggregated counts.</li><li><code>row_col</code>: Column determining the table rows.</li><li><code>col_col</code>: Column determining the table columns.</li><li><code>freq_col</code>: Column containing the integer counts/frequencies.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L189-L199">source</a></section></details></article><h3 id="Structures-and-Results"><a class="docs-heading-anchor" href="#Structures-and-Results">Structures &amp; Results</a><a id="Structures-and-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Structures-and-Results" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="HypothesisTestsExtra.PostHocTestResult"><a class="docstring-binding" href="#HypothesisTestsExtra.PostHocTestResult"><code>HypothesisTestsExtra.PostHocTestResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PostHocTestResult</code></pre><p>Container for the results of a post-hoc multiple comparison test.</p><p><strong>Fields</strong></p><ul><li><code>method::Symbol</code>: The name of the post-hoc method used (e.g., <code>:tukey</code>, <code>:bonferroni</code>).</li><li><code>comparisons::Vector{PostHocComparison}</code>: A list of all pairwise comparisons performed.</li><li><code>alpha::Float64</code>: The significance level used for the test (e.g., 0.05).</li><li><code>use_cld::Bool</code>: Whether Compact Letter Display (CLD) was calculated.</li><li><code>cld_letters::Dict{Int, String}</code>: Mapping of group indices to CLD letters (if applicable).</li><li><code>label_map::Dict{Int, String}</code>: Mapping of internal group indices back to original labels (e.g., &quot;Control&quot;, &quot;Treat&quot;).</li></ul><p><strong>Methods</strong></p><ul><li><code>DataFrame(res)</code>: Convert detailed pairwise results to a DataFrame.</li><li><code>GroupTestToDataframe(res)</code>: Convert CLD results to a DataFrame.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/PostHoc/posthoc_structures.jl#L43-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTestsExtra.PostHocComparison"><a class="docstring-binding" href="#HypothesisTestsExtra.PostHocComparison"><code>HypothesisTestsExtra.PostHocComparison</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PostHocComparison</code></pre><p>Stores the statistical results of a single pairwise comparison between two groups.</p><p><strong>Fields</strong></p><ul><li><code>group1::Int</code>: Index of the first group in the comparison.</li><li><code>group2::Int</code>: Index of the second group in the comparison.</li><li><code>diff::Float64</code>: The difference between means (Group1 - Group2).</li><li><code>se::Float64</code>: Standard Error of the difference.</li><li><code>statistic::Float64</code>: Test statistic (e.g., t-value or q-value).</li><li><code>crit_val::Float64</code>: Critical value for the test statistic at the specified alpha.</li><li><code>p_value::Float64</code>: Calculated p-value for the comparison.</li><li><code>lower_ci::Float64</code>: Lower bound of the confidence interval.</li><li><code>upper_ci::Float64</code>: Upper bound of the confidence interval.</li><li><code>rejected::Bool</code>: Boolean flag indicating if the null hypothesis was rejected (significant difference).</li><li><code>note::String</code>: Additional annotations or warnings (e.g., &quot;ns&quot;, &quot;***&quot;).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/PostHoc/posthoc_structures.jl#L11-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTestsExtra.ContingencyCellTestResult"><a class="docstring-binding" href="#HypothesisTestsExtra.ContingencyCellTestResult"><code>HypothesisTestsExtra.ContingencyCellTestResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ContingencyCellTestResult</code></pre><p>Stores the results of post-hoc cell-wise analysis for contingency tables (e.g., Adjusted Standardized Residuals).</p><p><strong>Fields</strong></p><ul><li><code>method::Symbol</code>: The method used for cell analysis (e.g., <code>:asr</code> for Adjusted Standardized Residuals).</li><li><code>adjust_method::Symbol</code>: P-value adjustment method for multiple comparisons (e.g., <code>:bonferroni</code>, <code>:fdr</code>).</li><li><code>observed::Matrix{Int}</code>: The original matrix of observed counts.</li><li><code>stats_matrix::Matrix{Float64}</code>: Matrix of test statistics (e.g., Z-scores for ASR or Odds Ratios).</li><li><code>pvals_matrix::Matrix{Float64}</code>: Matrix of raw p-values.</li><li><code>adj_pvals_matrix::Matrix{Float64}</code>: Matrix of adjusted p-values.</li><li><code>sig_matrix::Matrix{Bool}</code>: Boolean matrix indicating significance at the given alpha level.</li><li><code>alpha::Float64</code>: Significance level.</li><li><code>row_labels::Vector{String}</code>: Labels for the rows of the contingency table.</li><li><code>col_labels::Vector{String}</code>: Labels for the columns of the contingency table.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/PostHoc/posthoc_structures.jl#L172-L188">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTestsExtra.GroupTestToDataframe"><a class="docstring-binding" href="#HypothesisTestsExtra.GroupTestToDataframe"><code>HypothesisTestsExtra.GroupTestToDataframe</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">GroupTestToDataframe(res::PostHocTestResult)</code></pre><p>Get CLD (Compact Letter Display) labels of PostHocTestResult as a DataFrame. Returns columns: <code>GroupIndex</code>, <code>GroupLabel</code>, and <code>CLD</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/PostHoc/posthoc_structures.jl#L70-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTestsExtra.CellTestToDataframe"><a class="docstring-binding" href="#HypothesisTestsExtra.CellTestToDataframe"><code>HypothesisTestsExtra.CellTestToDataframe</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">CellTestToDataframe(res::ContingencyCellTestResult)</code></pre><p>Generate a matrix-form DataFrame from ContingencyCellTestResult. Cell content format is &quot;Value*&quot; (if significant) or &quot;Value&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/PostHoc/posthoc_structures.jl#L252-L257">source</a></section></details></article><h2 id="DataFrame-Extensions"><a class="docs-heading-anchor" href="#DataFrame-Extensions">DataFrame Extensions</a><a id="DataFrame-Extensions-1"></a><a class="docs-heading-anchor-permalink" href="#DataFrame-Extensions" title="Permalink"></a></h2><p><em>Note: These methods extend <code>HypothesisTests.jl</code> functions to accept DataFrame as inputs.</em></p><h3 id="Categorical-Tests"><a class="docs-heading-anchor" href="#Categorical-Tests">Categorical Tests</a><a id="Categorical-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Categorical-Tests" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="HypothesisTests.ChisqTest-Tuple{DataFrame, Symbol, Symbol}"><a class="docstring-binding" href="#HypothesisTests.ChisqTest-Tuple{DataFrame, Symbol, Symbol}"><code>HypothesisTests.ChisqTest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ChisqTest(df::DataFrame, row_col::Symbol, col_col::Symbol)</code></pre><p>Compute Pearson&#39;s Chi-square test from a raw DataFrame. Generates a contingency table internally. Requires at least a 2x2 table.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L209-L214">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTests.ChisqTest-Tuple{DataFrame, Symbol, Symbol, Symbol}"><a class="docstring-binding" href="#HypothesisTests.ChisqTest-Tuple{DataFrame, Symbol, Symbol, Symbol}"><code>HypothesisTests.ChisqTest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ChisqTest(df::DataFrame, row_col::Symbol, col_col::Symbol, freq_col::Symbol)</code></pre><p>Compute Pearson&#39;s Chi-square test from aggregated frequency data (Long format).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L226-L230">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTests.FisherExactTest-Tuple{DataFrame, Symbol, Symbol}"><a class="docstring-binding" href="#HypothesisTests.FisherExactTest-Tuple{DataFrame, Symbol, Symbol}"><code>HypothesisTests.FisherExactTest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FisherExactTest(df::DataFrame, row_col::Symbol, col_col::Symbol)</code></pre><p>Compute Fisher&#39;s Exact Test from a raw DataFrame. Currently supports only 2x2 tables. For RxC tables, use <code>FisherExactTestRxC</code>, which supports both the Monte Carlo Fisher&#39;s exact test (RxC) and the exact 2x2 test.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L251-L257">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTests.FisherExactTest-Tuple{DataFrame, Symbol, Symbol, Symbol}"><a class="docstring-binding" href="#HypothesisTests.FisherExactTest-Tuple{DataFrame, Symbol, Symbol, Symbol}"><code>HypothesisTests.FisherExactTest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FisherExactTest(df::DataFrame, row_col::Symbol, col_col::Symbol, freq_col::Symbol)</code></pre><p>Compute Fisher&#39;s Exact Test (2x2) from aggregated frequency data (Long format).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L291-L295">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTests.PowerDivergenceTest-Tuple{DataFrame, Symbol, Symbol}"><a class="docstring-binding" href="#HypothesisTests.PowerDivergenceTest-Tuple{DataFrame, Symbol, Symbol}"><code>HypothesisTests.PowerDivergenceTest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PowerDivergenceTest(df::DataFrame, row_col::Symbol, col_col::Symbol; lambda::Real=1.0)</code></pre><p>Compute Power Divergence Test (e.g., G-test if lambda=0) from a raw DataFrame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L315-L319">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTests.PowerDivergenceTest-Tuple{DataFrame, Symbol, Symbol, Symbol}"><a class="docstring-binding" href="#HypothesisTests.PowerDivergenceTest-Tuple{DataFrame, Symbol, Symbol, Symbol}"><code>HypothesisTests.PowerDivergenceTest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PowerDivergenceTest(df::DataFrame, row_col::Symbol, col_col::Symbol, freq_col::Symbol; lambda::Real=1.0)</code></pre><p>Compute Power Divergence Test from aggregated frequency data (Long format).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L330-L334">source</a></section></details></article><h3 id="K-Sample-and-Variance-Tests"><a class="docs-heading-anchor" href="#K-Sample-and-Variance-Tests">K-Sample &amp; Variance Tests</a><a id="K-Sample-and-Variance-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#K-Sample-and-Variance-Tests" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="HypothesisTests.OneWayANOVATest-Tuple{DataFrame, Symbol, Symbol}"><a class="docstring-binding" href="#HypothesisTests.OneWayANOVATest-Tuple{DataFrame, Symbol, Symbol}"><code>HypothesisTests.OneWayANOVATest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">OneWayANOVATest(df::DataFrame, group_col::Symbol, data_col::Symbol)</code></pre><p>Perform One-Way ANOVA to test equality of means across groups in a DataFrame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L349-L353">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTests.KruskalWallisTest-Tuple{DataFrame, Symbol, Symbol}"><a class="docstring-binding" href="#HypothesisTests.KruskalWallisTest-Tuple{DataFrame, Symbol, Symbol}"><code>HypothesisTests.KruskalWallisTest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">KruskalWallisTest(df::DataFrame, group_col::Symbol, data_col::Symbol)</code></pre><p>Perform Kruskal-Wallis Rank Sum Test (non-parametric ANOVA) on a DataFrame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L369-L373">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTests.LeveneTest-Tuple{DataFrame, Symbol, Symbol}"><a class="docstring-binding" href="#HypothesisTests.LeveneTest-Tuple{DataFrame, Symbol, Symbol}"><code>HypothesisTests.LeveneTest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LeveneTest(df::DataFrame, group_col::Symbol, data_col::Symbol)</code></pre><p>Perform Levene&#39;s Test for equality of variances across groups in a DataFrame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L379-L383">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTests.BrownForsytheTest-Tuple{DataFrame, Symbol, Symbol}"><a class="docstring-binding" href="#HypothesisTests.BrownForsytheTest-Tuple{DataFrame, Symbol, Symbol}"><code>HypothesisTests.BrownForsytheTest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BrownForsytheTest(df::DataFrame, group_col::Symbol, data_col::Symbol)</code></pre><p>Perform Brown-Forsythe Test (robust Levene&#39;s test using median) for equality of variances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L389-L393">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTests.FlignerKilleenTest-Tuple{DataFrame, Symbol, Symbol}"><a class="docstring-binding" href="#HypothesisTests.FlignerKilleenTest-Tuple{DataFrame, Symbol, Symbol}"><code>HypothesisTests.FlignerKilleenTest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FlignerKilleenTest(df::DataFrame, group_col::Symbol, data_col::Symbol)</code></pre><p>Perform Fligner-Killeen Test (non-parametric) for equality of variances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L399-L403">source</a></section></details></article><h3 id="Two-Sample-Tests"><a class="docs-heading-anchor" href="#Two-Sample-Tests">Two-Sample Tests</a><a id="Two-Sample-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Two-Sample-Tests" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="HypothesisTests.EqualVarianceTTest-Tuple{DataFrame, Symbol, Symbol}"><a class="docstring-binding" href="#HypothesisTests.EqualVarianceTTest-Tuple{DataFrame, Symbol, Symbol}"><code>HypothesisTests.EqualVarianceTTest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">EqualVarianceTTest(df::DataFrame, group_col::Symbol, data_col::Symbol)</code></pre><p>Perform Student&#39;s T-Test (assuming equal variance) between exactly two groups in a DataFrame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L413-L417">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTests.UnequalVarianceTTest-Tuple{DataFrame, Symbol, Symbol}"><a class="docstring-binding" href="#HypothesisTests.UnequalVarianceTTest-Tuple{DataFrame, Symbol, Symbol}"><code>HypothesisTests.UnequalVarianceTTest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">UnequalVarianceTTest(df::DataFrame, group_col::Symbol, data_col::Symbol)</code></pre><p>Perform Welch&#39;s T-Test (not assuming equal variance) between exactly two groups in a DataFrame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L423-L427">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTests.VarianceFTest-Tuple{DataFrame, Symbol, Symbol}"><a class="docstring-binding" href="#HypothesisTests.VarianceFTest-Tuple{DataFrame, Symbol, Symbol}"><code>HypothesisTests.VarianceFTest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VarianceFTest(df::DataFrame, group_col::Symbol, data_col::Symbol)</code></pre><p>Perform F-Test to compare the variances of exactly two groups in a DataFrame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L433-L437">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTests.MannWhitneyUTest-Tuple{DataFrame, Symbol, Symbol}"><a class="docstring-binding" href="#HypothesisTests.MannWhitneyUTest-Tuple{DataFrame, Symbol, Symbol}"><code>HypothesisTests.MannWhitneyUTest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MannWhitneyUTest(df::DataFrame, group_col::Symbol, data_col::Symbol)</code></pre><p>Perform Mann-Whitney U Test (Wilcoxon Rank Sum) between exactly two groups in a DataFrame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L443-L447">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HypothesisTests.ApproximateTwoSampleKSTest-Tuple{DataFrame, Symbol, Symbol}"><a class="docstring-binding" href="#HypothesisTests.ApproximateTwoSampleKSTest-Tuple{DataFrame, Symbol, Symbol}"><code>HypothesisTests.ApproximateTwoSampleKSTest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ApproximateTwoSampleKSTest(df::DataFrame, group_col::Symbol, data_col::Symbol)</code></pre><p>Perform Approximate Two-Sample Kolmogorov-Smirnov Test between exactly two groups in a DataFrame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/songtaogui/HypothesisTestsExtra.jl/blob/f08aacc31c25a84d1094dbca70da9bd1815f77dd/src/dataframe_ext.jl#L453-L457">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/dataframes/">« DataFrame Integration</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 21 January 2026 01:45">Wednesday 21 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
